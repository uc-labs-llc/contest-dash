const MOON_SIZE = 80; // Size for moon phase SVGs
const SVG_SIZE = 80; // Size for moonrise/moonset SVGs
const LOCATION = {
    name: "Los Ebanos",
    state: "Texas",
    timezone: "America/Chicago",
    // Latitude and Longitude for accurate moon calculation
    lat: 26.2434, 
    lng: -98.5617
};

/**
 * Calculates the current position of the moon relative to the horizon
 * for visualization on the canvas.
 * @param {number} canvasWidth - The width of the canvas.
 * @param {number} canvasHeight - The height of the canvas.
 * @returns {object} An object containing moon position (x, y), visibility, and time data.
 */
function getMoonPosition(canvasWidth, canvasHeight) {
    if (typeof SunCalc === 'undefined') {
        // This is a safety check assuming SunCalc is loaded via script tag
        throw new Error("SunCalc library failed to load. Please check your internet connection.");
    }
    try {
        const now = moment().tz(LOCATION.timezone);
        const moonTimes = SunCalc.getMoonTimes(now.toDate(), LOCATION.lat, LOCATION.lng);
        const moonPos = SunCalc.getMoonPosition(now.toDate(), LOCATION.lat, LOCATION.lng);
        const moonIllumination = SunCalc.getMoonIllumination(now.toDate());

        // Check for edge cases (e.g., polar regions where times might be undefined)
        if (!moonTimes.rise || !moonTimes.set) {
            return {
                visible: false,
                moonrise: 'N/A',
                moonset: 'N/A',
                current_time: now.format('h:mm A'),
                error: 'Moon times not calculable for this date/location.'
            };
        }

        const moonrise = moment(moonTimes.rise).tz(LOCATION.timezone);
        const moonset = moment(moonTimes.set).tz(LOCATION.timezone);

        const alt = moonPos.altitude * 180 / Math.PI; // Altitude (degrees)
        const az = moonPos.azimuth * 180 / Math.PI;   // Azimuth (degrees)

        const arcRadius = (canvasWidth - 40) / 2;
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight * 0.7;

        if (alt > 0) {
            // Moon is visible (above horizon)
            const dayLength = (moonset - moonrise) / 1000; // in seconds
            const elapsed = (now - moonrise) / 1000; // in seconds
            const progress = Math.min(1, Math.max(0, elapsed / dayLength));
            const angle = 180 * progress; // Angle from 0 (moonrise) to 180 (moonset)

            const rad = angle * Math.PI / 180;
            
            // Calculate X and Y position on the arc
            let x = centerX - arcRadius * Math.cos(rad) - MOON_SIZE / 2;
            let y = centerY - arcRadius * Math.sin(rad) - MOON_SIZE / 2;
            
            // Apply slight vertical adjustment for a more dramatic visual curve
            y = y - (90 - alt) * 0.6; 

            return {
                x: Math.max(0, Math.min(canvasWidth - MOON_SIZE, x)),
                y: Math.max(0, Math.min(canvasHeight - MOON_SIZE, y)),
                visible: true,
                altitude: Math.round(alt * 10) / 10,
                azimuth: Math.round(az * 10) / 10,
                moonrise: moonrise.format('h:mm A'),
                moonset: moonset.format('h:mm A'),
                current_time: now.format('h:mm A'),
                phaseName: getMoonPhaseName(moonIllumination.phase),
                phaseFraction: (moonIllumination.fraction * 100).toFixed(1),
                phaseSvgPath: getMoonPhaseSvg(moonIllumination.fraction, moonIllumination.phase)
            };
        }
        
        // Moon is below horizon
        return {
            visible: false,
            moonrise: moonrise.format('h:mm A'),
            moonset: moonset.format('h:mm A'),
            current_time: now.format('h:mm A'),
            altitude: Math.round(alt * 10) / 10,
            azimuth: Math.round(az * 10) / 10,
            phaseName: getMoonPhaseName(moonIllumination.phase),
            phaseFraction: (moonIllumination.fraction * 100).toFixed(1),
            phaseSvgPath: getMoonPhaseSvg(moonIllumination.fraction, moonIllumination.phase)
        };
    } catch (e) {
        console.error("Moon calculation error:", e.message);
        return {
            visible: false,
            error: `Calculation error: ${e.message}`
        };
    }
}

/**
 * Determines the correct SVG filename for the current moon phase.
 * @param {number} fraction - The illuminated fraction (0 to 1).
 * @param {number} phase - The phase angle (0 to 1).
 * @returns {string} The path to the moon phase SVG file.
 */
function getMoonPhaseSvg(fraction, phase) {
    if (phase >= 0 && phase <= 0.01 || phase >= 0.99 && phase <= 1) return 'images/new-moon.svg';
    if (phase > 0.01 && phase < 0.25) return 'images/waxing-crescent.svg';
    if (phase >= 0.24 && phase <= 0.26) return 'images/first-quarter.svg';
    if (phase > 0.26 && phase < 0.5) return 'images/waxing-gibbous.svg';
    if (phase >= 0.49 && phase <= 0.51 && fraction > 0.95) return 'images/full-moon.svg';
    if (phase > 0.5 && phase < 0.74) return 'images/waning-gibbous.svg';
    if (phase >= 0.74 && phase <= 0.76) return 'images/last-quarter.svg';
    if (phase > 0.76 && phase < 0.99) return 'images/waning-crescent.svg';
    return 'images/moon.svg'; // Fallback
}

/**
 * Provides a common name for the moon phase based on the phase angle (0..1).
 */
function getMoonPhaseName(phase) {
    if (phase >= 0 && phase <= 0.01 || phase >= 0.99 && phase <= 1) return 'New Moon';
    if (phase > 0.01 && phase < 0.25) return 'Waxing Crescent';
    if (phase >= 0.24 && phase <= 0.26) return 'First Quarter';
    if (phase > 0.26 && phase < 0.5) return 'Waxing Gibbous';
    if (phase >= 0.49 && phase <= 0.51) return 'Full Moon';
    if (phase > 0.5 && phase < 0.74) return 'Waning Gibbous';
    if (phase >= 0.74 && phase <= 0.76) return 'Last Quarter';
    if (phase > 0.76 && phase < 0.99) return 'Waning Crescent';
    return 'Unknown Phase';
}

/**
 * Draws the arc, moonrise/moonset icons, and the current moon phase SVG on the canvas.
 * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
 * @param {number} canvasWidth - The width of the canvas.
 * @param {number} canvasHeight - The height of the canvas.
 * @param {object} moonData - The data object returned by getMoonPosition.
 */
function drawForeground(ctx, canvasWidth, canvasHeight, moonData) {
    // Clear canvas before redrawing
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    const arcRadius = (canvasWidth - 40) / 2;
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight * 0.7;

    // Draw arc (horizon line/path)
    ctx.beginPath();
    // Start at 180 degrees (left) and end at 360 degrees (right)
    ctx.arc(centerX, centerY, arcRadius, Math.PI, 2 * Math.PI); 
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 0;
    ctx.lineCap = 'round';
    ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
    ctx.shadowBlur = 15;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Helper function to draw image with fallback error logging
    const drawIcon = (src, x, y) => {
        const img = new Image();
        img.src = src;
        img.onload = () => {
            ctx.drawImage(img, x, y, SVG_SIZE, SVG_SIZE);
        };
        img.onerror = () => {
            console.error(`Failed to load ${src}`);
        };
    };

    // Draw moonrise.svg at left endpoint
    drawIcon('images/moonrise.svg', 20 - SVG_SIZE / 2, centerY - SVG_SIZE / 2);

    // Draw moonset.svg at right endpoint
    drawIcon('images/moonset.svg', canvasWidth - 20 - SVG_SIZE / 2, centerY - SVG_SIZE / 2);

    // Draw phase-specific SVG if visible
    if (moonData.visible && moonData.phaseSvgPath) {
        drawIcon(moonData.phaseSvgPath, moonData.x, moonData.y);
    }
}

/**
 * Updates the information panel with current moon and location data.
 * @param {object} moonData - The data object returned by getMoonPosition.
 */
function updateInfo(moonData) {
    // Get the main containers
    const infoDiv = document.getElementById('info');
    const moonTimeRow = document.getElementById('moon-time-row');
    const latLonRow = document.getElementById('lat-lon-row');
    const moonPhaseRow = document.getElementById('moon-phase-row');

    // Ensure elements exist before manipulation
    if (!infoDiv || !moonTimeRow || !latLonRow || !moonPhaseRow) {
        console.error("Missing required HTML elements: #info, #moon-time-row, #lat-lon-row, or #moon-phase-row.");
        return;
    }
    
    // Always display the Location heading and current time
    const locationHeadingHTML = `<h2>${LOCATION.name}, ${LOCATION.state}</h2>`;
    const currentTimeParagraphHTML = `<p><strong>Time:</strong> ${moonData.current_time}</p>`;

    // Update static elements (Assumes h2 and first p are direct children of #info)
    const h2Element = infoDiv.querySelector('h2');
    if (h2Element) h2Element.outerHTML = locationHeadingHTML;

    const pElement = infoDiv.querySelector('p');
    if (pElement) pElement.outerHTML = currentTimeParagraphHTML;

    // Handle error state by displaying error and clearing rows
    if (moonData.error) {
        moonTimeRow.innerHTML = `<span class="moon-detail error" style="width: 100%; text-align: center;">${moonData.error}</span>`;
        latLonRow.innerHTML = `<span class="moon-detail status" style="width: 100%; text-align: center;">Check console for details.</span>`;
        moonPhaseRow.innerHTML = '';
        return;
    }

    // Insert Moonrise and Moonset into the horizontal row
    moonTimeRow.innerHTML = `
        <span class="moon-detail"><strong>Moonrise:</strong> ${moonData.moonrise}</span>
        <span class="moon-detail"><strong>Moonset:</strong> ${moonData.moonset}</span>
    `;
    
    // Insert Moon Phase details with SVG
// Change 'moonPhaseRow.innerHTML' in your JS file:
moonPhaseRow.innerHTML = `
    <span class="moon-detail">
        <strong>Phase:</strong> 
        <span class="moon-value-container">
            <img src="${moonData.phaseSvgPath}" alt="${moonData.phaseName}" style="width: 40px; height: 40px; vertical-align: middle;">
        </span>
    </span>
    <span class="moon-detail"><strong>Illumination:</strong> ${moonData.phaseFraction}%</span>
`;
    // Insert Altitude and Azimuth into the horizontal row
    if (moonData.visible) {
        latLonRow.innerHTML = `
            <span class="moon-detail"><strong>Altitude:</strong> ${moonData.altitude}°</span>
            <span class="moon-detail"><strong>Azimuth:</strong> ${moonData.azimuth}°</span>
        `;
    } else {
        // If moon is below the horizon, show status and Lat/Lon
        latLonRow.innerHTML = `
            <span class="moon-detail status" style="width: 100%; text-align: center;">Moon Status: Below horizon</span>
        `;
    }
}

/**
 * Main drawing function that recalculates moon position and updates canvas/info panel.
 */
function draw() {
    const canvas = document.getElementById('moonCanvas');
    if (!canvas) {
        console.error("Canvas element not found!");
        return;
    }
    const ctx = canvas.getContext('2d');

    // Define canvas size based on CSS fixed values for stability
    let canvasWidth = 600; 
    let canvasHeight = 450; 
    
    // Setting width/height properties based on your CSS definitions
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    const moonData = getMoonPosition(canvasWidth, canvasHeight);

    // Always update info panel before drawing, so info is ready on load
    updateInfo(moonData); 

    // Load background image
    const img = new Image();
    img.src = 'images/sky.jpg'; // Placeholder for the sky image
    img.onload = () => {
        ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
        drawForeground(ctx, canvasWidth, canvasHeight, moonData);
    };
    img.onerror = () => {
        console.error("Failed to load sky.jpg, using fallback background");
        // Add fallback class for CSS background gradient
        canvas.classList.add('fallback'); 
        drawForeground(ctx, canvasWidth, canvasHeight, moonData);
    };
}

// Handle window resize (to maintain responsiveness) and initial draw
window.addEventListener('resize', draw);

// Initial draw when the script loads
draw(); 

// Update the visualization every minute (60,000 milliseconds)
setInterval(draw, 60000);
